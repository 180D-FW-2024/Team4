# -*- coding: utf-8 -*-
"""fall detection sender

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TwDNSNSJWa8C6Y14Dn1ISuDZ-uzD9cWY
"""

import sys
import time
import math
import IMU
import datetime
import numpy as np
import tflite_runtime.interpreter as tflite
import socket
import json

# Load TFLite model and allocate tensors
interpreter = tflite.Interpreter(model_path="fall_detection_model.tflite")
interpreter.allocate_tensors()
input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()

# UDP Setup
UDP_IP = "192.168.1.16"  # Receiver's IP (main Raspberry Pi)
UDP_PORT = 5001          # Ensure this matches the receiver's port
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# IMU Setup
IMU.detectIMU()  # Detect if BerryIMU is connected
if IMU.BerryIMUversion == 99:
    print("No BerryIMU found... exiting")
    sys.exit()
IMU.initIMU()  # Initialize the accelerometer, gyroscope, and compass

# Sensitivity scale factors
ACC_SCALE = 0.061 * 0.00981
GYRO_SCALE = 8.75 * 0.0000174533
MAG_SCALE = 0.08 * 0.1

while True:
    # Read IMU data
    ACCx = IMU.readACCx() * ACC_SCALE
    ACCy = IMU.readACCy() * ACC_SCALE
    ACCz = IMU.readACCz() * ACC_SCALE
    GYRx = IMU.readGYRx() * GYRO_SCALE
    GYRy = IMU.readGYRy() * GYRO_SCALE
    GYRz = IMU.readGYRz() * GYRO_SCALE
    MAGx = IMU.readMAGx() * MAG_SCALE
    MAGy = IMU.readMAGy() * MAG_SCALE
    MAGz = IMU.readMAGz() * MAG_SCALE

    # Combine data into a single array for the model
    input_data = np.array([ACCx, ACCy, ACCz, GYRx, GYRy, GYRz, MAGx, MAGy, MAGz], dtype=np.float32)
    input_data = np.expand_dims(input_data, axis=0)

    # Run inference
    interpreter.set_tensor(input_details[0]['index'], input_data)
    interpreter.invoke()
    output_data = interpreter.get_tensor(output_details[0]['index'])

    # Determine if fall is detected (predicted_class 1 means fall)
    predicted_class = np.argmax(output_data)
    fall_detected = predicted_class == 1

    # Print and send fall detection result via UDP
    print(f"Fall detected: {fall_detected}")
    message = json.dumps({"fallDetected": fall_detected})
    sock.sendto(message.encode('utf-8'), (UDP_IP, UDP_PORT))

    # Sleep to control loop rate
    time.sleep(0.5)
